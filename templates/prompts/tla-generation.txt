You are an expert TLA+ engineer. Translate the distributed handler specification below into a sound and well-structured TLA+ module together with a TLC configuration that can be used for model checking.

Return ONLY valid JSON (no markdown, comments, or additional prose) that matches this schema exactly:
{
  "module": {
    "name": string,
    "extends": string[],
    "constants": [{ "name": string, "type"?: string, "value"?: string }],
    "variables": [{ "name": string, "type"?: string, "description"?: string }],
    "init": string,
    "actions": [
      {
        "name": string,
        "parameters": string[],
        "guards": string[],
        "updates": string[],
        "unchanged": string[]
      }
    ],
    "invariants": [{ "name": string, "predicate": string, "description"?: string }],
    "next": string,
    "spec": string,
    "source": string
  },
  "config": string
}

Requirements:
- Ensure the module is syntactically valid TLA+ and consistent with TLC.
- Always include a TypeOK invariant that constrains every state variable.
- Respect the provided fault model (duplicate delivery, reordering, crash/restart) with explicit actions.
- Honour bounds when declaring constants (e.g., account domains, retry limits, depth constraints).
- Use the handler signature and pre/postconditions to derive meaningful guards and state updates.
- Encode invariants such as idempotence, conservation, and atomicity explicitly in TLA+.
- The "source" field must contain the complete module text beginning with "---- MODULE" and ending with the module footer.
- Escape new lines as "\n" inside JSON strings (standard JSON encoding).
- Do not invent additional fields or omit mandatory ones. If unsure about a detail, make the minimal conservative assumption and document it in comments inside the TLA+ code.

Specification JSON:
{{SPEC_JSON}}
